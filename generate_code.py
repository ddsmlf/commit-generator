import os
import subprocess
import time
import re
from langchain_ollama import OllamaLLM
import argparse
import random
import sys

# Constants
MODEL_NAME = "deepseek-r1"

# Argument Parser
def parse_arguments():
    parser = argparse.ArgumentParser(description='Generate or modify a Python script with Ollama')
    parser.add_argument('-r', '--repo', required=True, help='Path to the repository')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-g', '--generate', action='store_true', help='Generate a Python script')
    group.add_argument('-f', '--fix', action='store_true', help='Fix an existing Python script')
    group.add_argument('-d', '--doc', action='store_true', help='Generate documentation for a script')
    group.add_argument('-c', '--clean', action='store_true', help='Push for repo cleanup')
    group.add_argument('-u', '--update', nargs='?', const=True, help='Update the code generation model with an optional description')
    group.add_argument('-a', '--all', action='store_true', help='Generate, fix and document a Python script')
    return parser.parse_args()

# Pipeline for all
def pipeline(repo_path):
    main(repo_path, True, False, False, False, False)
    main(repo_path, False, True, False, False, False)
    main(repo_path, False, False, True, False, False)

# Git Operations
def git_operations(repo_path, commit_message):
    subprocess.run(["git", "-C", repo_path, "add", "."])
    subprocess.run(["git", "-C", repo_path, "commit", "-m", commit_message])
    subprocess.run(["git", "-C", repo_path, "push", "origin", "main"])
    print("[✔] Push completed successfully!")

# Show Code
def show_code(code_response):
    s = input("Do you want to see the content generated by the model (Y/N) ")
    if s.lower() == 'y':
        print(code_response)

# Get Script Content
def get_script_content(prompt, llm, mode):
    print(f"[⏳] {mode} in progress...")
    response = llm.invoke(prompt)
    return response

# Generate Script
def generate_script(llm):
    prompt = """Generate a functional and interesting Python script for a complex algorithmic problem of your choice. Do not add any comments in the script. And do not add any superfluous text outside the Python script.
    Return only the response in this exact format:

    File name: $$$<script_name_without_extension>$$$
    Code:
    <script_content>
    """
    mode = "[ADD]"
    code_response = get_script_content(prompt, llm, mode)
    return code_response, mode, prompt

# Fix Script
def fix_script(llm, script_content, random_file):
    prompt = f"""Fix the following Python script, return the complete code without adding any comments and superfluous text outside the Python script:
    {script_content}
    """
    mode = "[FIX]"
    code_response = get_script_content(prompt, llm, mode)
    return code_response, mode, random_file, prompt

# Generate Documentation
def generate_doc(llm, script_content, random_file):
    prompt = f"""Generate Markdown documentation for the following Python script, return the complete code without adding any comments and superfluous text outside the Python script:
    {script_content}
    """
    mode = "[DOC]"
    code_response = get_script_content(prompt, llm, mode)
    file_name = random_file.replace(".py", ".md")
    return code_response, mode, file_name, prompt

# Run Model
def run_model():
    subprocess.run(["ollama", "pull", MODEL_NAME])
    time.sleep(2)
    subprocess.Popen(["ollama", "serve", MODEL_NAME])
    print("[✔] Model 'deepseek' ready!")

    llm = OllamaLLM(model=MODEL_NAME)
    return llm

# Update documentation of main function
def update_doc_main(repo_path, new_fetaure):
    #read the actuel doc :
    with open(os.path.join(repo_path, "README.md"), "r") as f:
        doc = f.read()
    # read the new version of the code
    with open(os.path.join(repo_path, "generate_code.py"), "r") as f:
        code = f.read()
    # run model
    llm = run_model()
    prompt = f"""Update this Markdown documentation :
    ```markdown
    {doc}
    ```
    New feature to add in the documentation: "{new_fetaure}"
    Update jsute the section version of the documentation utilisation if parameter has been changed.

    Return only the complete Markdown documentation updated. Don't add any comments or superfluous text outside the Markdown documentation.
    """
    code_response = get_script_content(prompt, llm, "Documentation update")
    try :
        new_doc = re.search(r'```markdown(.*)```', code_response, re.DOTALL).group(1).strip()
        with open(os.path.join(repo_path, "README.md"), "w") as f:
            f.write(new_doc)
        print("[✔] Documentation updated")
    except Exception as e:
        print(f"[❌] Error: {e}\nDocumentation not updated.")
        show_code(code_response)
        r = input("Press Enter to exit or R to retry...")
        if r.lower() == "r":
            update_doc_main(repo_path, new_fetaure)
        else:
            exit()

# Main Function
def main(repo_path, generate, fix, doc, clean, update=None):
    if clean:
        git_operations(repo_path, "[CLEAN] Cleanup of generated files")
    elif update:
        subprocess.run(['git', '-C', repo_path, 'pull'])
        if update == True:
            new_fetaure = input("Description of the new feature: ")
        else:
            new_fetaure = update
        update_doc_main(repo_path, new_fetaure)
        git_operations(repo_path, f"[FEAT] {new_fetaure}")
    else:
        llm = run_model()
        if generate:
            code_response, mode, prompt = generate_script(llm)
        else:
            generated_files = os.listdir(os.path.join(repo_path, "generated"))
            generated_files = [file for file in generated_files if not file.endswith(".md")]
            if not generated_files:
                print("[❌] No generated files found.")
                sys.exit(1)

            random_file = random.choice(generated_files)
            file_path = os.path.join(repo_path, "generated", random_file)
            with open(file_path, "r") as f:
                script_content = f.read()

            if doc:
                code_response, mode, file_name, prompt = generate_doc(llm, script_content, random_file)
            elif fix:
                code_response, mode, file_name, prompt = fix_script(llm, script_content, random_file)

        while True:
            try:
                if generate or fix:
                    extension = ".py"
                    script_content_match = re.search(r'```python(.*?)```', code_response, re.DOTALL)
                else:
                    extension = ".md"
                    script_content_match = re.search(r'```markdown(.*)```', code_response, re.DOTALL)

                if script_content_match:
                    script_content = script_content_match.group(1).strip()
                    print("[✔] Script content found.")
                    break
                else:
                    print("[❌] Error: Script content not found.")
                    show_code(code_response)
                    r = input("Press Enter to exit or R to retry...")
                    if r.lower() == "r":
                        code_response = get_script_content(prompt, llm, mode)
                    else:
                        exit()
            except Exception as e:
                print(f"[❌] Error: {e}\nScript content not found.")
                show_code(code_response)
                r = input("Press Enter to exit or R to retry...")
                if r.lower() == "r":
                    code_response = get_script_content(prompt, llm, mode)
                else:
                    exit()

        if generate:
            try:
                file_name_line = re.search(r'\$\$\$(.*?)\$\$\$', code_response).group(1)
                script_name = file_name_line.replace(" ", "_").replace("-", "_")
            except Exception as e:
                print(f"[❌] Error with script name: {e}")
                show_code(code_response)
                script_name = input("Enter the script name: ")
            file_name = f"generated/{script_name}.{extension}"
            file_path = os.path.join(repo_path, file_name)

        with open(file_path, "w") as f:
            f.write(script_content)

        print(f"[✔] File created: {file_path}")
        git_operations(repo_path, f"{mode} {file_name.replace('generated/', '')}")

if __name__ == "__main__":
    args = parse_arguments()
    sum = sum([args.generate, args.fix, args.doc, args.clean, bool(args.update), args.all]) 
    if sum == 0:
        generate = True
    elif sum != 1:
        print("""❌ Please choose only one option among:
              -g, --generate : Generate a Python script
              -f, --fix : Fix an existing Python script
              -d, --doc : Generate documentation for a script
              -c, --clean : Push for repo cleanup
              -u, --update : Update the code generation model with an optional description
              -a, --all : Generate, fix and document a Python script (3 pushes)
              """)
        sys.exit(1)
    else:
        if args.all:
            pipeline(args.repo)
            sys.exit(0)
        generate = args.generate
    fix = args.fix
    doc = args.doc
    clean = args.clean
    update = args.update
    main(args.repo, generate, fix, doc, clean, update)
